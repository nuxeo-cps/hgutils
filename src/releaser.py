# (C) Copyright 2010 Georges Racinet <georges@racinet.fr>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as published
# by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.
#
# $Id$

import os
import logging
from datetime import datetime

from mercurial.node import short as hg_hex
import mercurial.patch
from mercurial import commands as hg_commands

from bundleman.utils import parseZopeVersionFile, parseNuxeoVersionFile
from bundleman.utils import parseVersionString, parseNuxeoChanges

logger = logging.getLogger('hgbundler.releaser')

def gen_or_list_bool(gl):
    """Same logic as bool(gl) except that it accepts lists and generators.

    Consumes generator first object.
    Use-case : mercurial.patch.diff returns list in 1.6.4 (Debian's 1.6.4-1)
    """
    if isinstance(gl, list):
        return bool(gl)
    try:
        gl.next()
    except StopIteration:
        return False
    return True



class RepoReleaseError(Exception):
    pass


class Releaser(object):
    """Encapsulates all non-mercurial gathered from local copy to release it.

    Most of this class is adapted from bundleman.productman
    """

    tpl_changes = """Requires
~~~~~~~~
-
New features
~~~~~~~~~~~~
-
Bug fixes
~~~~~~~~~
-
New internal features
~~~~~~~~~~~~~~~~~~~~~
- %s
"""
    tpl_version = """#BUNDLEMAN PRODUCT CONFIGURATION FILE
# do not edit this file
PKG_NAME=%s
PKG_VERSION=%s
PKG_RELEASE=%s
"""


    def __init__(self, desc, release_again=False, increment_major=False):
        self.release_again = release_again
        self.increment_major = increment_major
        self.desc = desc
        self.repo = desc.getRepo()
        self.branch = desc.getName()
        self.parseChanges()
        if self.initial:
            self.setInitialVersion()
        else:
            self.parseVersion()

    def parseChanges(self):
        """Return the change type."""
        desc = self.desc
        changes_path = os.path.join(desc.local_path, 'CHANGES')
        content = ''
        try:
            content = open(changes_path).read()
        except IOError:
            # no changes file, but still recognized, that means initial release
            self.changes = ([], [], [], [])
            self.initial = True
        else:
            self.changes = parseNuxeoChanges(content)
            self.initial = False

    def updateVersionFiles(self):
        fpath = self.desc.local_path

        if self.initial:
            changes = history = ''
        else:
            changes = open(os.path.join(fpath, 'CHANGES')).read()
            history = open(os.path.join(fpath, 'HISTORY')).read()
        f = open(os.path.join(fpath, 'HISTORY'), 'w+')

        prod_name = self.product_name
        prod_version = self.version_new[0]

        header = """===========================================================
Package: %s %s
===========================================================
First release built by: %s at: %s
""" % (prod_name, prod_version, os.getenv('USER'),
       datetime.now().isoformat()[:19])
        f.write(header)
        f.write(changes)
        f.write('\n')
        f.write(history)
        f.close()

        # set up VERSION
        f = open(os.path.join(fpath, 'VERSION'), 'w+')
        args = self.version_new
        args.insert(0, prod_name)
        f.write(self.tpl_version % tuple(args))
        f.close()

    def initChangesFile(self):
        f = open(os.path.join(self.desc.local_path, 'CHANGES'), 'w+')
        f.write(self.tpl_changes % '')
        f.close()

    def setInitialVersion(self):
        self.product_name = os.path.split(self.desc.local_path_rel)[-1]
        self.version_str = '0.0.0'
        self.release_nr = '0'
        return

    def parseVersion(self):
        """Extract name, version, release from VERSION or version.txt file.

        Adapted from bundleman.productman
        """
        ret = [None, None, None]
        content = None
        desc = self.desc

        for file_name in ('version.txt', 'VERSION.txt', 'VERSION'):
            version_path = os.path.join(desc.local_path, file_name)
            try:
                content = open(version_path).read()
                break
            except IOError:
                continue

        try:
            if file_name == 'VERSION':
                ret = parseNuxeoVersionFile(content)
            else:
                ret = parseZopeVersionFile(content)
        except ValueError:
            logger.error("Invalid version file %s  contents in branch %s "
                         "of %s", file_name, self.branch,
                         desc.local_path_rel)
        if not ret[0]:
            ret[0] = os.path.split(desc.target)[-1]

        self.product_name = ret[0]
        self.version_str = ret[1]
        self.release_nr = ret[2] and int(ret[2]) or None

    def changedSinceTag(self, node, tag_name=None):
        tag_ctx = self.repo.changectx(node)
        def branch_children(ctx):
            return [c for c in ctx.children() if c.branch() == self.branch]

        children = branch_children(tag_ctx)
        base_error_msg = ("Previous tag %s (from VERSION) " +
                         "not done by hgbundler. ")
        if len(children) != 1:
            logger.error(base_error_msg + "The tagged changeset would "
                         "otherwise have exactly."
                         "one child (commit of tag).", tag_name)
            self.dumpLogSince(tag_ctx.node())
            raise RepoReleaseError

        children = branch_children(children[0])
        if len(children) != 1:
            logger.error(base_error_msg + "The tag commit "
                         "would otherwise have exactly one child (reinit of "
                         "CHANGES). ", tag_name)
            self.dumpLogSince(tag_ctx.node())
            raise RepoReleaseError

        node1 = children[0].node()
        logger.debug("Checking diff since changeset %s", hg_hex(node1))
        if not gen_or_list_bool(mercurial.patch.diff(self.repo, node1=node1)):
            return False

        logger.warn("Diff since last release (node %s) not empty.",
                    hg_hex(node))
        self.dumpLogSince(node1)
        return True

    def dumpLogSince(self, node):
        current_ctx = self.repo.changectx(None)
        current_node = current_ctx.node()
        if current_node is None:
            current_node = current_ctx.parents()[0].node()

        noderange = hg_hex(node), hg_hex(current_node)
        logger.info("Running hg log on %s since %s on branch '%s'.",
                    self.desc.local_path_rel, hg_hex(node), self.branch)
        hg_commands.log(self.repo.ui, self.repo,
                        rev=[':'.join(noderange)],
                        only_branch=[self.branch],
                        date=None, user=None)

    def newVersion(self):
        """Computes the new version of the product.

        Return True if a new tag must be made,
               False if an existing tag must be used instead of the branch,
               None if no action is to be taken
        """
        if self.initial:
            logger.warn("No CHANGES file found in the branch '%s', "
                         "of %s. Assuming initial release", self.branch,
                         self.desc.local_path_rel)
            if self.increment_major:
                self.version_new = ['1.0.0', 1]
            else:
                self.version_new = ['0.0.1', 1]
            return True

        changes = self.changes
        name = self.product_name
        release = self.release_nr

        version_str = self.version_str
        version = parseVersionString(version_str)
        if not filter(None, changes) or not version:
            tag_node = self.repo.tags().get(self.version_str)
            if tag_node is None:
                if self.version_str:
                    # need to create the tag
                    return self.version_str, self.release_nr
                else:
                    # not a versioned product
                    return None

            if self.changedSinceTag(tag_node, tag_name=self.version_str):
                if not self.release_again:
                    logger.error("Changes since tag %s for %s (branch '%s') "
                                 "but empty CHANGES file",
                                 self.version_str, self.desc.local_path_rel,
                                 self.desc.getName())
                    raise RepoReleaseError()
            else:
                logger.info("Already released: %s (branch '%s') as tag %s. "
                            "Nothing to do",
                            self.desc.local_path_rel, self.desc.getName(),\
                            self.version_str)
                return False

        if changes[0] or changes[1] or changes[3]:
            # any requires/features/int. features
            release = 1
            if self.increment_major:
                # major++
                version[0] += 1
                version[1] = 0
                version[2] = 0
            else:
                # minor++
                version[1] = version[1] + 1
                version[2] = 0
        elif changes[2]:
            # bug fixes
            release = 1
            version[2] = version[2] + 1
        else:
            # release again
            release += 1
        str_version = '.'.join(map(str, version)[:-1])
        if self.branch != 'default':
            # setup branch flag
            str_version += '-' + self.branch
        self.version_new = [str_version, str(release)]
        return True

    def tag(self):
        tag = self.version_new[1]
        msg = "hgbundler made release tag"
        hg_commands.tag(self.repo.ui, self.repo, tag, message=msg)
        return tag

